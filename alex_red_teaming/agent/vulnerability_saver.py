"""Vulnerability saving agent."""

from loguru import logger
import uuid
from alex_red_teaming.models import RedTeamingState, Vulnerability
from alex_red_teaming.config import Config
from alex_red_teaming.utils import save_json, create_output_dir


class VulnerabilitySaver:
    """Agent responsible for saving discovered vulnerabilities."""

    def __init__(self, config: Config):
        self.config = config
        self.output_dir = None  # Will be created on first save

    def _extract_full_history(
        self, state: RedTeamingState
    ) -> tuple[str, str, int, dict]:
        """Get full conversation history as tagged blocks and raw logs.

        Returns:
            attack_block: string with all red_team messages tagged [ATTACK i]
            response_block: string with all target messages tagged [RESPONSE i]
            turns: total number of messages considered (attacks+responses)
            raw_logs: {"red_team": [...], "target": [...]} for metadata
        """
        attack_block = ""
        response_block = ""
        turns = 0
        raw_logs = {"red_team": [], "target": []}

        conv = state.current_conversation
        if not conv:
            return attack_block, response_block, turns, raw_logs

        logs = conv.metadata.get("ai_vs_ai_logs")
        if logs and (logs.get("red_team") or logs.get("target")):
            red_list = logs.get("red_team", [])
            tgt_list = logs.get("target", [])
            raw_logs = {"red_team": list(red_list), "target": list(tgt_list)}
            attack_block = "\n\n".join(
                [f"[ATTACK {i+1}] {t}" for i, t in enumerate(red_list)]
            )
            response_block = "\n\n".join(
                [f"[RESPONSE {i+1}] {t}" for i, t in enumerate(tgt_list)]
            )
            turns = len(red_list) + len(tgt_list)
            return attack_block, response_block, turns, raw_logs

        # Fallback to linear messages: map user->red_team, assistant->target
        red_list = [m.content for m in conv.messages if m.role == "user"]
        tgt_list = [m.content for m in conv.messages if m.role == "assistant"]
        raw_logs = {"red_team": list(red_list), "target": list(tgt_list)}
        attack_block = "\n\n".join(
            [f"[ATTACK {i+1}] {t}" for i, t in enumerate(red_list)]
        )
        response_block = "\n\n".join(
            [f"[RESPONSE {i+1}] {t}" for i, t in enumerate(tgt_list)]
        )
        turns = len(conv.messages)
        return attack_block, response_block, turns, raw_logs

    async def save_vulnerability(self, state: RedTeamingState) -> RedTeamingState:
        """Save a discovered vulnerability."""
        if not state.current_conversation or not state.current_conversation.success:
            logger.error("No vulnerability to save")
            return state

        logger.info("Saving discovered vulnerability")

        analysis = state.current_conversation.metadata.get("last_analysis", {})
        attack_block, response_block, conv_turns, raw_logs = self._extract_full_history(
            state
        )

        vulnerability = Vulnerability(
            id=str(uuid.uuid4()),
            type=state.current_vulnerability_type,
            severity=state.current_conversation.severity,
            title=f"{state.current_vulnerability_type.value.replace('_', ' ').title()} Vulnerability",
            description=analysis.get(
                "explanation", "Vulnerability detected through red-teaming"
            ),
            attack_vector=attack_block,
            conversation_id=state.current_conversation.id,
            proof_of_concept=response_block,
            mitigation_suggestions=[],
            metadata={
                "confidence": analysis.get("confidence", 0),
                "evidence": analysis.get("evidence", ""),
                "conversation_turns": conv_turns,
                "ai_vs_ai_logs": raw_logs,
                "transcript_format": "tagged_blocks",
            },
        )

        state.discovered_vulnerabilities.append(vulnerability)
        logger.info(f"Vulnerability saved. Total found: {state.issues_found}")

        # Save vulnerability to file immediately
        try:
            # Create output directory once and reuse it
            if self.output_dir is None:
                self.output_dir = create_output_dir(self.config.output.output_dir)

            vuln_file = (
                self.output_dir
                / "vulnerabilities"
                / f"vulnerability_{vulnerability.id}.json"
            )
            save_json(vulnerability.to_dict(), vuln_file)
            logger.info(f"Vulnerability saved to file: {vuln_file}")
        except Exception as e:
            logger.error(f"Error saving vulnerability to file: {e}")

        # Reset current conversation since we've saved the vulnerability
        state.current_conversation = None
        state.conversation_turn = 0

        return state
