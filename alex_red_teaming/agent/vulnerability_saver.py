"""Vulnerability saving agent."""

from loguru import logger
import uuid
from alex_red_teaming.models import RedTeamingState, Vulnerability
from alex_red_teaming.config import Config
from alex_red_teaming.utils import save_json, create_output_dir


class VulnerabilitySaver:
    """Agent responsible for saving discovered vulnerabilities."""

    def __init__(self, config: Config):
        self.config = config
        self.output_dir = None  # Will be created on first save

    def _extract_last_pair(self, state: RedTeamingState) -> tuple[str, str, int]:
        """Get last (attack, response) and turn count from logs or messages."""
        attack = ""
        response = ""
        turns = 0
        conv = state.current_conversation
        if not conv:
            return attack, response, turns

        logs = conv.metadata.get("ai_vs_ai_logs")
        if logs and logs.get("red_team") and logs.get("target"):
            attack = logs["red_team"][-1]
            response = logs["target"][-1]
            # each pair is two messages
            turns = min(len(logs["red_team"]), len(logs["target"])) * 2
            return attack, response, turns

        # Fallback to linear messages
        if len(conv.messages) >= 2:
            attack = conv.messages[-2].content
            response = conv.messages[-1].content
            turns = len(conv.messages)
        return attack, response, turns

    async def save_vulnerability(self, state: RedTeamingState) -> RedTeamingState:
        """Save a discovered vulnerability."""
        if not state.current_conversation or not state.current_conversation.success:
            logger.error("No vulnerability to save")
            return state

        logger.info("Saving discovered vulnerability")

        analysis = state.current_conversation.metadata.get("last_analysis", {})
        attack, poc, conv_turns = self._extract_last_pair(state)

        vulnerability = Vulnerability(
            id=str(uuid.uuid4()),
            type=state.current_vulnerability_type,
            severity=state.current_conversation.severity,
            title=f"{state.current_vulnerability_type.value.replace('_', ' ').title()} Vulnerability",
            description=analysis.get(
                "explanation", "Vulnerability detected through red-teaming"
            ),
            attack_vector=attack,
            conversation_id=state.current_conversation.id,
            proof_of_concept=poc,
            mitigation_suggestions=[
                "Implement additional safety filters",
                "Improve training on edge cases",
                "Add monitoring for this vulnerability type",
            ],
            metadata={
                "confidence": analysis.get("confidence", 0),
                "evidence": analysis.get("evidence", ""),
                "conversation_turns": conv_turns,
            },
        )

        state.discovered_vulnerabilities.append(vulnerability)
        logger.info(f"Vulnerability saved. Total found: {state.issues_found}")

        # Save vulnerability to file immediately
        try:
            # Create output directory once and reuse it
            if self.output_dir is None:
                self.output_dir = create_output_dir(self.config.output.output_dir)

            vuln_file = (
                self.output_dir
                / "vulnerabilities"
                / f"vulnerability_{vulnerability.id}.json"
            )
            save_json(vulnerability.to_dict(), vuln_file)
            logger.info(f"Vulnerability saved to file: {vuln_file}")
        except Exception as e:
            logger.error(f"Error saving vulnerability to file: {e}")

        # Reset current conversation since we've saved the vulnerability
        state.current_conversation = None
        state.conversation_turn = 0

        return state
